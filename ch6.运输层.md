# 运输层

## 运输层概述

### 为什么需要运输层

+ 网络层已经解决的问题：

	+ 提供**不可靠**、**无连接**、**尽力而为**的数据报传送服务

	+ 将数据报从一台主机经过网络送到另一台主机，实现主机之间的通信（不严格）

		> 两台主机进行通信是两台主机中的**应用进程互相通信**

+ 网络层未解决的问题：

	+ 主机中谁发送的数据、谁接收数据
	+ IP数据报无序到达目的主机，接收进程如何处理
	+ 可靠传输问题

### 运输层位置

运输层属于面向**通信部分**的最高层，同时也是面向**用户功能**的最低层

### 运输层的作用

+ 为网络中相互通信的主机的应用进程提供完整的**端到端的逻辑通信服务**

+ 对于低层用户而言，主要起**管控作用**，实现可靠传输、流量控制、拥塞控制、运输连接管理等功能
+ 对于高层用户而言，运输层**屏蔽**网络核心的细节，使**应用进程(AP)**看见的是在两个运输层实体间有一条**D2D的逻辑通信信道**

### 运输层和网络层的区别

+ 网络层为主机之间提供逻辑通信，通信的两端是**两台主机**（IP的作用范围）
+ 运输层为应用进程之间提供端到端的逻辑通信，通信的两端是**主机中的进程**（UDP和TCP的作用范围）

### 运输层的复用和分用![运输层-复用和分用](images\运输层-复用和分用.png)

在一台主机中经常有多个应用进程同时分别和零一台主机中的多个应用进程通信，这表明运输层的复用和分用功能

+ 复用：不同应用进程都可以通过同一个运输层协议传送数据
+ 分用：运输层从网络层收到发送给应用进程的数据后，必须分别交付给指明的各应用进程

### 运输层的端口

为指明各应用进程，使用**进程标识符**(操作系统给每个进程定义一个唯一标识该进程的非负正数)，但主机操作系统很多，不同系统使用不同格式的进程标识符，难以统一。

+ 解决办法：运输层使用**协议端口号**（简称端口）

+ 运输层端口就是运输层的服务访问点

+ 端口用来**标识应用层的进程**，让应用层的进程都能将其数据通过端口向下交付给运输层，也可以让运输层知道应当将报文段从哪个端口交付给相应的进程

+ 端口类型：硬件端口、软件端口、TCP/IP运输层端口

	+ 硬件端口：交换机或路由器上的端口
	+ 软件端口：协议栈层间抽象的端口，进程与运输实体层间交互的地址
	+ TCP/IP运输层端口：**16位**端口号，允许有65535个不同的端口号；只具有**本地意义**，表示本计算机应用层中的各进程；不同计算机的相同端口号**无关联**

	> 两台计算机进程通信的前提：1）知道对方的IP地址 2）知道对方的端口号

+ 两大类、三种类型端口号：服务器端口号、客户端口号、注册端口号

	+ 服务器端口号0~1023：也叫知名端口号，在全球通用，由IANA统一分配
	+ 客户端口号49152~65535：临时端口号，只有在用户运行该客户进程时才存在，本机唯一
	+ 注册端口号1024~49151：用于一些不常用服务，使用前需注册

### 运输层协议

#### UDP

+ 传输数据之前不需要先建立连接
+ 收到UDP报文后不需要给任何确认
+ 支持单播、多播、广播
+ 不提供可靠服务，但是一种最有效的工作方式
+ 适用于对效率要求高、对准确性要求低的场景，如视频聊天

#### TCP

+ 传输数据之前需要先建立连接，提供可靠的，面向连接的运输服务
+ 收到TCP报文段后需要确认
+ 支持点对点单播，不提供广播或多播服务
+ 协议复杂，开销较大，占用较多的处理机资源
+ 适用于对效率要求低，准确性要求高的场景，如电话联系

## 用户数据报协议（UDP）

### UDP的功能

UDP只在IP数据报服务上增加了少量功能

+ 复用和分用
+ 差错检测

### UDP的主要特点

UDP通信的特点：简单方便，但不可靠

+ 无连接。发送数据前不需要建立连接，减小了开销和时延
+ 使用尽最大努力交付。不保证可靠交付，主机不需要维持复杂的连接状态表
+ 面向报文。一次传送和交付一个完整的报文
+ 没有拥塞控制
+ 支持一对一、一对多、多对一、多对多等交互通信
+ 首部开销小。只有8个字节，TCP首部20字节

### UDP是面向报文的协议

+ 发送端：

	+ UDP对应用程序交下来的报文，在**添加首部**后直接向下**交付给IP层**
	+ UDP对应用层交下来的报文，**既不合并**，**也不拆分**，而是**保留这些报文的边界**
	+ UDP收到应用层多长的报文，就照样发送多长的报文，即**一次发送一个报文**

+ 接收端：

	+ UDP对IP层交付上来的UDP用户数据报，**去除首部**后**原封不动地交付上层**的应用进程
	+ **一次交付一个完整的报文**

	> 应用进程必须选择合适大小的报文：
	>
	> 1）若报文太长，UDP把它交付给IP层后，IP在传送时需要**分片**，降低效率
	>
	> 2）若报文太短，UDP把它交付给IP层后，会使IP数据报的**首部相对长度太大**，降低效率

+ 分用和复用：

	![分用复用](images\分用复用.png)

	+ 分用：将UDP用户数据报组装成不同的IP数据报，发送到互联网
	+ 复用：根据UDP用户数据包首部中的目的端口号，将数据包分别传送到相应的端口

### UDP数据报格式

![UDP数据包格式](images\UDP数据包格式.png)

#### 首部字段

共占8个字节，由4个字段组成，每个字段都是2个字节

+ 源端口：源端口号。在需要对方回信时选用，不需要时可全用0。如果源主机是客户端，则是临时端口号；若源主机是服务器，则是知名端口号
+ 目的端口：目的端口号。终点交付报文时必须使用。如果目的主机是客户端，则是临时端口号；若目的主机是服务器，则是知名端口号
+ 长度：UDP用户数据报的长度（包括首部和数据，以字节为单位），当仅有首部时，长度为8字节（最小值），作用是便于目标端计算出数据长度
+ 校验和：检测UDP用户数据报（计算范围包括首部和数据部分）在传输中是否有错

#### 伪首部

![伪首部](images\伪首部.png)

+ 为计算校验和，临时添加了伪首部
+ 可以理解为UDP的**两次检查**：
	+ **对IP地址进行校验**（伪首部中含有源IP地址和目的地址），确认该IP数据包是发送给本主机的
	+ **对端口号和数据进行校验**（伪首部中含UDP长度），确认数据是无误的
+ 发送端操作：
	+ 添加伪首部，UDP首部校验和填充0
	+ 数据部分长度为4字节整数倍，不足填0
	+ 计算校验和，**伪首部+首部+数据**
	+ 首部填上校验和
	+ 删除伪首部，发送UDP数据报
+ 接收端操作：
	+ 增加伪首部
	+ 计算校验和，**伪首部+首部+数据**
	+ 校验和全1无差错，否则丢弃或叫上应用进程（附带错误警告）

## 传输控制协议（TCP）

### 特点

+ 面向连接：采用协议的方法确保通信双方有一条全双工的、可靠的逻辑信道，字节按序发送并按序接收
+ 实现点对点通信，每条TCP连接只能有两个端点，只能是点对点通信
+ 提供可靠交付的服务，不会出现差错、丢失、重复、失序现象
+ 提供全双工通信
+ 面向字节流的协议，TCP把应用程序交下来的数据看成是**一连串无结构的字节流**,TCP不保证接收端收到的**数据块与发送端具有对应大小的关系，但字节流完全一样**。

### TCP连接

+ TCP连接的端点是**套接字（socket）**，每条TCP连接唯一地被通信两端的套接字确定

	> 套接字::=(IP地址：端口号)
	>
	> $TCP连接::=\{socket_1, socket_2\}=\{(IP_1:port_1), (IP_2:port_2)\}$

### TCP报文段格式

![TCP报文段格式](images\TCP报文段格式.png)

+ 源端口和目的端口：各占2字节。复用和分用通过端口实现

+ 序号：占4字节。TCP传送的数据流中每一个字节都有一个序号，序号字段的值是**本报文段所发送的数据的第一个字节的序号**，范围是$[0, 2^{32}-1]$

+ 确认号：占4字节，若确认号=N，则表明到序号N-1为止的所有数据均已正确收到，并期望收到对方的下一个报文段的数据的第一个字节序号

+ 数据偏移：占4位，即**首部长度**，指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。以**4字节为计算单位**，由于4字节最大值15，因此首部长度最大值为60字节，即选项字段的长度不能超过40

+ 控制位：
	+ 紧急URG：URG=1时表明此报文段有紧急数据，应尽快传送
	+ 确认ACK：当ACK=1时，确认号才有效；ACK=0时，确认号无效
	+ 推送PSH：PSH=1时，应尽快交付接受应用进程，而不在等到整个缓存都填满后再交付
	+ 复位RST：RST=1时，TCP连接中出现严重差错，必须释放连接后重新建立连接
	+ 同步SYN：SYN=1时，表明这是连接请求或连接接收报文；SYN=1，ACK=0时，表明这是连接请求报文；SYN=1，ACK=1时，表明这是一个连接接收报文
	+ 终止FIN：FIN=1时，表示此报文段发送端的数据已发送完毕，要求释放连接
	
+ 窗口：占2字节，告诉对方本报文段从首部的确认号算起，接收方目前允许对方发送的数据量，动态变化

+ 校验和：占2字节，范围包括首部和数据，并在计算校验和是要加上12字节的伪首部

+ 紧急指针：占2字节，在紧急URG=1时有效，指出本报文段中紧急数据的字节数，即指出紧急数据末尾在报文段中的位置

+ 选项：长度可变。最大报文段长度MSS

	> TCP报文段长度 = TCP首部长度 + MSS
	>
	> MSS不能太大：IP层传输时要分片，终端要重组；分片传输出错时，要重传整个分组
	>
	> MSS不能太小：网络利用率降低
	>
	> MSS应尽可能大：保证在IP层传输时不再分片的前提下尽可能大。默认值536字节，报文段长度556字节，IP数据报长度576字节

	选项还包括窗口扩大、时间戳、选择性确认

+ 填充：使整个TCP首部长度是4字节整数倍

### TCP连接管理

+ TCP连接管理的目的是要保证运输连接的建立和释放均能正常进行
+ TCP连接三个阶段：
	+ 连接建立
	+ 数据传输
	+ 连接释放
+ TCP连接过程中要解决的问题：
	+ 要使每一方确知对方的存在
	+ 允许双方协商一些参数
	+ 对运输实体资源进行分配
+ TCP连接采用客户（client）-服务器（server）方式：主动发起连接的是客户，被动等待的是服务器
+ TCP规定：
	+ SYN报文段（SYN=1）不能携带数据，但要分配一个序号
	+ ACK报文段可以携带数据，若不携带数据，则不分配序号
	+ FIN报文段即（FIN=1）使不携带数据，也要分配一个序号

#### 连接建立（三报文握手）

![连接建立](images\连接建立.png)

+ 采用三报文握手是为了防止已失效的连接请求报文段又突然收到了

#### 释放释放（四报文握手）

![连接释放](images\连接释放.png)

+ MSL：最长报文段寿命
+ 必须等待2MSL：为了保证A发送的最后一个ACK报文段能够到达B；防止已失效的连接请求报文段出现在本连接中
+ 保活计时器：为了防止TCP长时期空闲，通常设置为2小时，若服务器2小时没有收到客户的数据，就会发送探测报文段，每75s发送一个报文段，若发送10个仍没有效应，则认为客户主机出现故障，终止该连接

### TCP传输控制

#### 可靠传输

在不可靠的传输信道实现可靠传输，必须使用一些可靠传输协议

+ 停止等待协议

	+ 停止等待：每发送完一个分组就停止发送，等待对方的确认，收到确认后发送下一个分组

	+ 暂存：发送完一个分组后，发送方暂存已发送的副本，以备重发

	+ 编号：对每个发送的分组和确认都进行编号

	+ 超时重传:为发送的分组设置超时计时器，若超时器到时间仍未收到确认，发送方自动超时重传分组

		> 重传时间比分组传输平均往返时间更长一些

	+ 简单，信道利用率低

+ 连续ARQ协议

	![滑动窗口](images\滑动窗口.png)

	+ 发送方维持发送窗口大小，窗口中的所有数据可以连续发出，不需要等待对方确认
	+ 已发送过的数据，未收到确认的需要暂时保留
	+ 使用滑动窗口协议，每收到一个确认，发送窗口就会向前滑动
	+ 每个报文段都会设置计时器，确认超时则重传报文段

	> 当A的发送窗口已满，可用窗口为0，且A仍未收到确认时，可能B未发送，也可能B发送但未到达A。
	>
	> 此时为保证可靠传输，A只能超时重传，直到收到B的确认位置
	>
	> A按序收到来自B的确认，则发送窗口向前滑动；若B收到未按序的数据，则不会发送确认，将失序数据暂存，待收到缺少数据时再发送确认

	+ 发送窗口由于**时延**和接收窗口不总是一样大

	+ 接收方必须有**累计确认**的功能：不必对分组逐个发送确认，而是对按序到达的**最后一个分组发送确认**

		> 收到一连串最大长的报文段，则必须**每隔一个报文段**就发送一个确认

+ 回退N（Go-Back-N）ARQ协议

	![GBN协议](images\GBN协议.png)

由于M2丢失，接收方只会对M1进行确认；M3、M4虽然到达，但因未按序到达，也会被**丢弃**。

>缺点：不能向发送方反应出接收方已经正确收到的所有分组信息

+ 选择性确认（SACK）ARQ协议

	![SACK选项](images\SACK选项.png)

	+ SACK允许选项：在**建立TCP连接**时，双方在**SYN报文段**或**SYN+ACK报文段**添加SACK允许选项，类型4，长度2

		![SACK](images\SACK.png)

	+ SACK信息选项：接受方报告收到的不连续的字节块的边界，**最多**可以指明**4个字节块**的边界信息，类型5，长度可变
	
		>左边界 = 第一个字节的序号
		>
		>右边界 = 最后一个字节序号 + 1

#### 流量控制（滑动窗口机制）

让发送方的发送速率不要太快，既要让接收方来得及接收，也不会使网络发生拥塞

> 窗口大小 = min(接收窗口， 拥塞窗口）

![流量控制](images\流量控制.png)

+ 死锁：上图中A发送完501-600序号的数据，由于B的接收窗口已满，则A不再发送；B经处理后允许A再发送400字节的数据，但ACK确认报文段丢失，A不收到确认报文段，仍认为B接收窗口已满，故不再发送
+ 解决办法：设置**持续计时器**
	+ 只要TCP连接的一方收到对方的**零窗口通知**，就启动该计时器
	+ 若计时器时间到期，就发送一个零窗口探测报文段（仅携带1字节数据），对方会在确认探测报文段时给出最新的窗口值
	+ 若窗口仍是0，则重新设置持续计时器
	+ 若窗口不是0，则打破死锁僵局

#### 超时重传

+ TCP每发送一个报文段，就会对这个报文段设置一次计时器

+ 计时器重传时间到了，但还没收到确认，就会重传这一报文段

+ 超时重传时间（RTO）设置要适中

	+ **不能太短**：会引起很多不必要的重传，增大网络负荷
	+ **不能太长**：网络空闲时间增大，降低传输效率

+ 计算RTO：根据往返时间（RTT）设置RTO

	加权平均往返时间$RTT_{S}$（平滑的RTT）:
	$$
	RTT_{S_{new}} = (1-\alpha) \times RTT_{S_{old}} + \alpha \times RTT_{new}
	$$
	$\alpha$越大，RTT的值更新得越快，RFC6289推荐$\alpha$为$\frac{1}{8}$

	RTO时间应略大于$RTT_S$：
	$$
	RTO=RTT_S+4 \times RTT_D
	$$
	上式中，RTT_D是RTT的偏差的加权平均值，RTT_S是加权平均往返时间
	$$
	RTT_{D_{new}} = (1-\beta) \times RTT_{D_{old}} + \beta \times \lvert {RTT_s - RTT_{new}} \rvert
	$$
	RFC建议这样计算$RTT_D$，第一次测量时，$RTT_D$取值为测量到的$RTT$样本值的一半，以后测量中，用上式计算$RTT_{D_{new}}$，$\beta$ 推荐为0.25

+ RTT测量难度很大：

	+ 若TCP报文段没有收到确认，重传后收到了确认。如何判定此确定是对原来的报文段的确认，还是对重传的报文段的确认？

		![超时重传](images\超时重传.png)

		>Karn算法：在计算平均往返RTT时，只要报文段重传了，就不采用其往返时间样本

	+ 当报文段的时延突然增大很多，即在原来RTO内不会收到确认报文，但根据Karn算法，不好考虑重传报文段的时间样本，导致RTO无法及时更新

		> 修正Karn算法：每重传一次，就把RTO增大一些
		> $$
		> RTO_{new}=\gamma \times RTO_{old}
		> $$
		> $\gamma$ 典型值取2；不再发生重传时，才会根据报文段的往返时延更新RTT和RTO。

### TCP拥塞控制

+ 拥塞：对网络中某资源的需求超过了该资源所能提供的部分，网络的性能就要明显变坏，网络的吞吐量会随输入负荷的增大而下降，最坏的结果的是系统崩溃
+ 超时可以作为判断网络拥塞的依据；吞吐量未饱和时，就会有部分输入分组被丢弃
+ 增加资源不能解决拥塞，甚至会使网络的性能更坏：
	+ 增大缓存，但是没有提高输出链路的容量和处理机的速度，排队时间会大大增加，导致大量超时重传
	+ 提高处理机处理的速率会将瓶颈转移到其他地方
	+ 拥塞引起的重传不会缓解网络的拥塞，反而会家具拥塞
+ 拥塞控制相较于流量控制：
	+ 拥塞控制是全局性的过程；流量控制是端到端的问题
	+ 拥塞控制防止太多数据注入到网络中，避免网络中设备过载；流量控制是抑制发送端的速率，使接收端来得及接收
+ 开环控制与闭环控制：
	+ 开环控制：实现考虑周全，一旦系统运行起来，不能中途进行改正。力争避免发生拥塞
	+ 闭环控制：基于网络当前的运行状态采取相应的控制措施。在发生拥塞后才需措施控制，消除拥塞
+ 相关概念：拥塞窗口、通告窗口、慢启动阈值、往返时间、快速重传阈值
	+ 拥塞窗口：发送端在拥塞控制情况下一次最多能发送的报文段数量
	+ 通告窗口：接收端给发送端预设的发送窗口大小
	+ 慢启动阈值：拥塞控制中慢启动阶段和拥塞避免阶段的分界点，防止拥塞窗口增长过大引起拥塞
	+ 往返时间：一个报文段从发送端发出直到收到接收端返回的确认的时间间隔
	+ 重传超时：一个报文段从发送到失效的时间间隔
	+ 快速重传阈值：能触发发送端进入快速重传的同一报文段重复确认的数目。档次数目超过快速重传阈值时，进入快速重传截断

#### 慢启动

![慢启动](images\慢启动.png)

+ 目的：探测网络的负载能力或拥塞程度
+ 算法思路：由小到大逐渐增大注入到网络中的数据字节，即逐渐增大拥塞窗口数值
+ 拥塞窗口(cwnd)初始值设置：1）1至2个最大报文段MSS ；2）2至4个MSS
+ 慢启动阈值(ssthresh)：当cwnd < ssthresh时，使用慢启动算法； 当cwnd > ssthresh时，使用拥塞避免算法；当cwnd = ssthresh时，两种算法都可以使用

+ 发送方每收到一个对新报文段的确认，就使cwnd加1
+ 每经过一轮的传输，cwnd就会加倍
+ 虽然叫慢启动，但是拥塞窗口大小按指数增加，并不慢！

#### 拥塞避免

![拥塞避免](images\拥塞避免.png)

+ 目的：让拥塞窗口缓慢增大，避免出现拥塞
+ 算法思路：使cwnd按先行规律缓慢增长，没经过一个往返时间RTT，发送方的cwnd就加1
+ 具有加法增大的特点
+ 拥塞避免不能完全避免拥塞，只是让拥塞窗口增长得缓慢些，使网络不容易出现拥塞

#### 乘法减小

+ 无论是慢启动阶段还是拥塞避免截断，只要发送方判断网络出现拥塞（重传定时器超时）：

	迅速执行下列操作

	+ ssthresh = max(cwnd / 2,2)
	+ cwnd = 1
	+ 执行慢启动算法

+ 目的：迅速减小主机向网络发送的分组数，使发生拥塞的路由有足够时间把积压在队列中的分组处理完毕

#### 快速重传

![快速重传](images\快速重传.png)

+ 目的：让发送方尽早知道发生了个别报文段的丢失
+ 算法思路：要求接受方立即发送确认，即使收到了失序的报文段，也要立即发送。发送到只要收到了连续三个确认，就立即进行重传，这样就不会超时也不会拥塞

> 快速重传并没有取消重传计时器，只是在某些情况下更早地重传报文

#### 快速回复

当发送端连续收到3个连续的重复确认时，发送方认为网络没有拥塞，因此不执行慢启动算法，转而执行快速恢复算法。

+ ssthresh = 当前 cwnd / 2
+ 乘法减小拥塞窗口， 新的cwnd = ssthresh 或 ssthresh + 3
+ 执行拥塞避免算法，使拥塞窗口线性增大

#### 总结

+ 慢启动，每个RTT内，收到一个确认，cwnd + 1
+ 拥塞避免：每个RTT内，收到多少确认，cwnd只加1
+ 乘法减小：超时重传或收到3个连续确认，ssthresh = cwnd / 2
+ 快速重传：收到3个连续确认，立即重传丢失的报文段
+ 快速恢复：收到3个连续确认，ssthresh = cwnd / 2，执行拥塞避免算法

> 发送窗口上限值 = min （接收窗口，拥塞窗口）
>
> 接收窗口（rwnd） < 拥塞窗口（cwnd）时，接受能力限制发送窗口
>
> 接收窗口（rwnd） > 拥塞窗口（cwnd）时，网络拥塞限制发送窗口